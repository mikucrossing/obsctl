<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>obsctl GUI</title>
  <style>
    :root{
      --bg: #0b0f14;
      --panel: #0f172a;
      --panel2: #111827;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --border: #243244;
      --ring: #60a5fa;
      --accent: #60a5fa;
      --success: #34d399;
      --error: #f87171;
    }
    *{ box-sizing: border-box }
    /* WebView を完全透過にし、ネイティブのぼかしを見せる */
    html, body { background: rgba(0,0,0,0); }
    body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif; margin: 0; color: var(--text); }
    /* 半透明レイヤにして背後(ネイティブ)の霜ガラスを活かす */
    header {
      background: rgba(17,24,39,0.50);
      padding: 12px 16px 12px 76px; /* 左に余白: 交通信号ボタンの干渉を避ける */
      position: sticky; top: 0; z-index: 10;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      /* Wails: この領域をドラッグ可能にする */
      --wails-draggable: drag;
      -webkit-user-select: none;
      cursor: default;
    }
    /* クリック可能要素はドラッグ対象外（Wailsのドラッグ判定はCSS変数） */
    button, input, select, textarea, a { --wails-draggable: none; }
    h1 { font-size: 16px; margin: 0; font-weight: 600; letter-spacing: .2px; }
    main { display: grid; grid-template-columns: 240px 1fr; gap: 0; height: calc(100vh - 54px); }
    aside { background: rgba(17,24,39,0.35); border-right: 1px solid rgba(255,255,255,0.08); padding: 10px; overflow: auto; }
    .nav { display: grid; gap: 6px; }
    .nav button { text-align: left; width: 100%; color: var(--text); background: transparent; border: 1px solid transparent; border-radius: 8px; padding: 8px 10px; }
    .nav button:hover { background: #0b1220; border-color: var(--border); }
    .nav button.active { background: #0b1220; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(96,165,250,0.2) inset; }
    #content { padding: 16px; overflow: auto; }
    .card { background: rgba(15,23,42,0.40); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 12px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    input, select, button { background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 8px; padding: 8px 10px; height: 34px; }
    /* Pull-downs too wide: keep compact by default */
    /* Compact pull-downs */
    select { width: 160px; max-width: 160px; min-width: 0; }
    /* Specific compact selects */
    #imp-conn { width: 160px; max-width: 160px; }
    #midi-device, #midi-gen-conn { width: 160px; max-width: 160px; }
    input[type="checkbox"] { width: auto; height: auto; padding: 0; margin: 0 6px 0 0; border: none; background: transparent; height: auto; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--ring); box-shadow: 0 0 0 2px rgba(96,165,250,0.25); }
    button { cursor: pointer; }
    .grow { flex: 1 1 220px; min-width: 200px; }
    .muted, small { color: var(--muted); }
    .list { display: grid; gap: 8px; }
    /* Connection cards */
    .conn-card { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 10px; display: grid; gap: 10px; }
    .conn-head { display: flex; align-items: center; gap: 8px; }
    .conn-head .spacer { flex: 1; }
    .fields { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .field { display: grid; gap: 4px; }
    .field label { font-size: 12px; color: var(--muted); }
    .btn-ghost { background: transparent; border: 1px solid var(--border); color: var(--muted); }
    /* Icon button for QR */
    .icon-btn { background: #0b1220; border: 1px solid #334155; border-radius: 8px; width: 34px; height: 34px; display: inline-flex; align-items: center; justify-content: center; padding: 0; }
    .icon-btn:hover { background: #0b1220; border-color: #334155; }
    .icon-btn svg { width: 18px; height: 18px; fill: currentColor; color: var(--text); opacity: 0.9; }
    .icon-btn img { width: 18px; height: 18px; opacity: 0.9; }
    /* QR overlay */
    .qr-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: grid; place-items: center; z-index: 1000; }
    .qr-modal { background: rgba(15,23,42,0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 12px; width: min(92vw, 520px); }
    .qr-video-wrap { position: relative; width: 100%; aspect-ratio: 4/3; background: #111; border-radius: 10px; overflow: hidden; }
    .qr-video { width: 100%; height: 100%; object-fit: cover; }
    .qr-box { position: absolute; inset: 10% 12%; border: 2px solid rgba(96,165,250,0.9); border-radius: 8px; box-shadow: 0 0 0 9999px rgba(0,0,0,0.25) inset; }
    .qr-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
    .qr-msg { margin: 8px 0; color: var(--muted); font-size: 12px; min-height: 18px; }
    .log { height: 300px; overflow: auto; background: rgba(11,18,32,0.45); border: 1px solid rgba(255,255,255,0.10); border-radius: 8px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }
    .scenes { height: 360px; overflow: auto; border: 1px solid rgba(255,255,255,0.10); border-radius: 8px; padding: 8px; background: rgba(11,18,32,0.45); }
    .scene { padding: 8px 10px; border-radius: 6px; cursor: pointer; }
    .scene:hover { background: #1f2937; }
    .ok { color: var(--success); }
    .ng { color: var(--error); }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .hidden { display: none; }
    /* iOS-like switch */
    .switch { position: relative; display: inline-block; width: 44px; height: 24px; vertical-align: middle; line-height: 0; border-radius: 9999px; overflow: hidden; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .switch .slider { position: absolute; cursor: pointer; inset: 0; background: #334155; border-radius: 9999px; transition: background .2s ease; border: 0; }
    .switch .slider:before { content:""; position: absolute; height: 20px; width: 20px; left: 2px; top: 2px; background: #ffffff; border-radius: 50%; transition: transform .2s ease; }
    .switch input:checked + .slider { background: var(--accent); border-color: var(--accent); }
    .switch input:checked + .slider:before { transform: translateX(20px); }
    /* Keep focus ring subtle to avoid visual bleed */
    .switch input:focus-visible + .slider { box-shadow: inset 0 0 0 1px rgba(96,165,250,0.25); }
  </style>
  <script src="./js/jsqr.js"></script>
  <script>
    function $(q){ return document.querySelector(q) }
    function el(name, attrs={}, text){ const e=document.createElement(name); Object.entries(attrs).forEach(([k,v])=>e.setAttribute(k,v)); if(text) e.textContent=text; return e }

    let currentConfig = null
    let scenes = []
    let scenesLoaded = false
    let autosaveTimer = null

    async function loadConfig(){
      try{
        currentConfig = await window.go.main.App.GetConfig()
        renderConnections()
        renderImportDefaults()
      }catch(e){ appendLog('error','設定の読み込みに失敗: '+e) }
    }

    function renderConnections(){
      const list = $('#conn-list')
      list.innerHTML = ''
      const pwd = $('#common-password')
      pwd.value = currentConfig.common_password || ''
      pwd.oninput = ()=>{ currentConfig.common_password = pwd.value; if(currentConfig.common_password===undefined) currentConfig.common_password=''; scheduleAutoSave() }
      ;(currentConfig.connections || []).forEach((c, idx) => {
        const card = el('div', {class:'conn-card'})
        const head = el('div', {class:'conn-head'})
        const name = el('input', {placeholder:'名前', value:c.name||''}); name.className='grow'
        const spacer = el('div', {class:'spacer'})
        // iOS-like switch
        const sw = el('label', {class:'switch'})
        const enabled = el('input', {type:'checkbox', 'aria-label':'有効'})
        enabled.checked = c.enabled !== false
        const slider = el('span', {class:'slider'})
        sw.append(enabled, slider)
        const del = el('button', {class:'btn-ghost'}, '削除')
        del.onclick = ()=>{ currentConfig.connections.splice(idx,1); renderConnections() }
        head.append(name, spacer, sw, del)

        const hp = splitAddr(c.addr||'')
        const fields = el('div', {class:'fields'})
        const fHost = el('div', {class:'field'})
        const lHost = el('label', {}, 'サーバーIP')
        const host = el('input', {placeholder:'localhost', value: hp.host || 'localhost'})
        fHost.append(lHost, host)
        const fPort = el('div', {class:'field'})
        const lPort = el('label', {}, 'サーバーポート')
        const port = el('input', {type:'number', min:'1', max:'65535', value: hp.port || '4455'})
        fPort.append(lPort, port)
        fields.append(fHost, fPort)

        card.append(head, fields)
        list.append(card)

        // 双方向反映
        name.oninput = ()=>{ currentConfig.connections[idx].name = name.value; scheduleAutoSave() }
        const updateAddr = ()=>{
          const h = (host.value||'').trim()
          let p = parseInt(port.value,10); if(!Number.isFinite(p) || p <=0 || p>65535){ p = 4455 }
          currentConfig.connections[idx].addr = h ? `${h}:${p}` : ''
        }
        host.oninput = ()=>{ updateAddr(); scheduleAutoSave() }
        port.oninput = ()=>{ updateAddr(); scheduleAutoSave() }
        enabled.onchange = ()=>{ currentConfig.connections[idx].enabled = enabled.checked; scheduleAutoSave() }
      })
    }

    function splitAddr(addr){
      try{
        let a = (addr||'').trim()
        if(a.startsWith('ws://')) a = a.slice(5)
        if(a.startsWith('wss://')) a = a.slice(6)
        let host = a, port = 4455
        const i = a.lastIndexOf(':')
        if(i>0){ const tail = a.slice(i+1); if(/^\d+$/.test(tail)){ host = a.slice(0,i); port = parseInt(tail,10) } }
        return {host, port}
      }catch(e){ return {host:'', port:4455} }
    }

    function renderImportDefaults(){
      const d = currentConfig.import_defaults || {}
      $('#imp-loop').checked = !!d.loop
      $('#imp-activate').checked = !!d.activate
      $('#imp-transition').value = d.transition || 'fade'
      $('#imp-monitoring').value = d.monitoring || 'off'
      const sel = $('#imp-conn'); sel.innerHTML = ''
      ;(currentConfig.connections||[]).filter(c=>c.enabled!==false).forEach(c=>{ const label=c.name||c.addr; sel.append(el('option', {value:c.name, title: label}, label)) })
      const genSel = $('#midi-gen-conn'); if(genSel){ genSel.innerHTML=''; (currentConfig.connections||[]).filter(c=>c.enabled!==false).forEach(c=>{ const label=c.name||c.addr; genSel.append(el('option',{value:c.name, title: label}, label)) }) }
    }

    function addConnection(){
      if(!currentConfig.connections) currentConfig.connections = []
      const name = ensureUniqueName(nextObsName())
      currentConfig.connections.push({name, addr:'localhost:4455', enabled:true})
      renderConnections(); scheduleAutoSave()
    }

    function nextObsName(){
      const used = new Set()
      ;(currentConfig.connections||[]).forEach(c=>{
        const m = String(c.name||'').trim().match(/^OBS\s+(\d+)$/i)
        if(m){ const n = parseInt(m[1],10); if(Number.isFinite(n)&&n>0) used.add(n) }
      })
      for(let i=1;i<9999;i++){ if(!used.has(i)) return `OBS ${i}` }
      return 'OBS'
    }

    function ensureUniqueName(base){
      const names = new Set((currentConfig.connections||[]).map(c=>String(c.name||'').trim().toLowerCase()))
      let name = String(base||'').trim() || 'OBS'
      if(!names.has(name.toLowerCase())) return name
      for(let i=2;i<1000;i++){
        const cand = `${name} (${i})`
        if(!names.has(cand.toLowerCase())) return cand
      }
      return `${name}-${Date.now()}`
    }

    // --- QR Scan: camera-based ---
    let __qrModal = null, __qrVideo = null, __qrStream = null, __qrDetector = null, __qrScanActive = false
    let __qrCanvas = null, __qrCtx = null
    async function addByQR(){
      openQrModal()
      try { await startQrScan() } catch(e){ setQrMsg('カメラ起動に失敗: '+ e) }
    }
    function openQrModal(){
      if(__qrModal){ __qrModal.classList.remove('hidden'); return }
      const overlay = el('div', {class:'qr-overlay', id:'qr-overlay'})
      const modal = el('div', {class:'qr-modal'})
      const title = el('div', {}, 'QRコードをカメラで読み取ります')
      const videoWrap = el('div', {class:'qr-video-wrap'})
      const video = el('video', {class:'qr-video', autoplay:'', playsinline:''})
      const box = el('div', {class:'qr-box'})
      videoWrap.append(video, box)
      // drag-and-drop fallback (画像から読み取り)
      videoWrap.addEventListener('dragover', (e)=>{ e.preventDefault(); videoWrap.style.outline='2px dashed rgba(96,165,250,0.8)' })
      videoWrap.addEventListener('dragleave', ()=>{ videoWrap.style.outline='' })
      videoWrap.addEventListener('drop', async (e)=>{
        e.preventDefault(); videoWrap.style.outline=''
        try{
          const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]
          if(!f || !/^image\//.test(f.type)){ setQrMsg('画像ファイルをドロップしてください'); return }
          const bmp = await createImageBitmap(f)
          // Try BarcodeDetector first if available
          let decoded = ''
          if('BarcodeDetector' in window){
            try{
              const det = __qrDetector || new window.BarcodeDetector({ formats:['qr_code'] })
              const codes = await det.detect(bmp)
              if(codes && codes.length){ decoded = codes[0].rawValue || '' }
            }catch(_){ /* fallthrough to jsQR */ }
          }
          if(!decoded && window.jsQR){
            try{
              const cnv = document.createElement('canvas')
              const w = bmp.width, h = bmp.height
              cnv.width = w; cnv.height = h
              const ctx = cnv.getContext('2d')
              ctx.drawImage(bmp, 0, 0, w, h)
              const imageData = ctx.getImageData(0, 0, w, h)
              const res = window.jsQR(imageData.data, imageData.width, imageData.height)
              if(res && res.data){ decoded = res.data }
            }catch(err){ setQrMsg('画像解析に失敗: '+err); return }
          }
          if(decoded){ await onQrDecoded(decoded) }
          else { setQrMsg('画像からQRが見つかりませんでした') }
        }catch(err){ setQrMsg('画像解析に失敗: '+err) }
      })
      const msg = el('div', {class:'qr-msg', id:'qr-msg'}, '')
      const actions = el('div', {class:'qr-actions'})
      const cancel = el('button', {class:'btn-ghost'}, 'キャンセル')
      cancel.onclick = closeQrModal
      actions.append(cancel)
      modal.append(title, videoWrap, msg, actions)
      overlay.append(modal)
      document.body.append(overlay)
      __qrModal = overlay; __qrVideo = video
      overlay.addEventListener('click', (e)=>{ if(e.target === overlay) closeQrModal() })
    }
    function setQrMsg(s){ const m = document.getElementById('qr-msg'); if(m) m.textContent = s || '' }
    async function startQrScan(){
      setQrMsg('カメラを初期化中…')
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          setQrMsg('この環境ではカメラAPIが利用できません');
          return
        }
        __qrStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
      }catch(e){
        const name = (e && e.name) ? e.name : 'Error'
        const msg = (e && e.message) ? e.message : String(e)
        setQrMsg(`カメラにアクセスできません (${name}): ${msg}`)
        // macOS のカメラ権限パネルを開くリンクを提示
        addOpenPrivacyHint()
        return
      }
      __qrVideo.srcObject = __qrStream
      try{ await __qrVideo.play() }catch(e){ /* ignore */ }
      setQrMsg('QRコードを枠内に収めてください')
      __qrScanActive = true
      if('BarcodeDetector' in window){
        try{ __qrDetector = new window.BarcodeDetector({ formats: ['qr_code'] }) }catch(e){ __qrDetector = null }
      }
      if(!__qrDetector && window.jsQR){
        setQrMsg('QRコード読み取り中…')
      } else if(!__qrDetector && !window.jsQR){
        setQrMsg('QRライブラリを読み込めませんでした')
      }
      scanLoop()
    }
    function addOpenPrivacyHint(){
      try{
        const actions = document.querySelector('.qr-actions'); if(!actions) return
        // 既に追加済みならスキップ
        if(actions.querySelector('#open-privacy')) return
        const open = el('button', {id:'open-privacy'}, 'カメラ権限を開く')
        open.onclick = ()=>{ try{ window.go.main.App.OpenExternalURL('x-apple.systempreferences:com.apple.preference.security?Privacy_Camera') }catch(_){} }
        actions.prepend(open)
      }catch(_){ /* noop */ }
    }
    async function scanLoop(){
      if(!__qrScanActive) return
      try{
        if(__qrDetector){
          const codes = await __qrDetector.detect(__qrVideo)
          if(codes && codes.length){ const val = codes[0].rawValue || codes[0].rawValue || ''; if(val) { await onQrDecoded(val); return } }
        } else if(window.jsQR && __qrVideo && __qrVideo.readyState >= 2){
          const vw = __qrVideo.videoWidth || 0
          const vh = __qrVideo.videoHeight || 0
          if(vw > 0 && vh > 0){
            if(!__qrCanvas){ __qrCanvas = document.createElement('canvas'); __qrCtx = __qrCanvas.getContext('2d') }
            // Downscale for performance, keep aspect
            const scale = Math.min(640 / vw, 1)
            const cw = Math.max(1, Math.floor(vw * scale))
            const ch = Math.max(1, Math.floor(vh * scale))
            __qrCanvas.width = cw; __qrCanvas.height = ch
            __qrCtx.drawImage(__qrVideo, 0, 0, cw, ch)
            const imageData = __qrCtx.getImageData(0, 0, cw, ch)
            const res = window.jsQR(imageData.data, imageData.width, imageData.height)
            if(res && res.data){ await onQrDecoded(res.data); return }
          }
        }
      }catch(e){ /* ignore transient errors */ }
      setTimeout(scanLoop, 120)
    }
    async function onQrDecoded(text){
      __qrScanActive = false
      setQrMsg('読み取り: '+text)
      stopQr()
      // Parse and add connection
      const parsed = parseObswsString(text)
      if(!parsed){ appendLog('error','QRの内容を解析できませんでした'); closeQrModal(); return }
      if(!currentConfig.connections) currentConfig.connections = []
      const name = ensureUniqueName(parsed.name || `OBS ${parsed.addr}`)
      currentConfig.connections.push({ name, addr: parsed.addr, enabled: true })
      if(parsed.password){
        if(!currentConfig.common_password){ currentConfig.common_password = parsed.password }
        else if(currentConfig.common_password !== parsed.password){ if(confirm('共通パスワードが異なります。上書きしますか？')){ currentConfig.common_password = parsed.password } }
      }
      renderConnections(); renderImportDefaults(); appendLog('info','QRから接続を追加しました'); scheduleAutoSave(); closeQrModal()
    }
    function closeQrModal(){ __qrScanActive = false; stopQr(); if(__qrModal) __qrModal.remove(); __qrModal = null; __qrVideo = null }
    function stopQr(){ try{ if(__qrStream){ __qrStream.getTracks().forEach(t=>t.stop()) } }catch(e){}; __qrStream = null; __qrCanvas = null; __qrCtx = null }

    function parseObswsString(input){
      try{
        let s = (input||'').trim(); if(s === '') return null
        let urlStr = s
        if(/^obsws:\/\//i.test(s)) urlStr = 'http://' + s.replace(/^obsws:\/\//i,'')
        else if(/^wss?:\/\//i.test(s)) urlStr = s.replace(/^wss?:\/\//i,'http://')
        else if(/^[\w\.-]+:\d{2,6}$/.test(s)) urlStr = 'http://' + s
        const u = new URL(urlStr)
        const addr = u.host
        const password = u.searchParams.get('password') || u.searchParams.get('pass') || u.searchParams.get('pw') || ''
        const name = `OBS ${u.hostname}`
        return { addr, password, name }
      }catch(e){
        const m = input.match(/([\w\.-]+:\d{2,6}).*?(?:password|pass|pw)[:=\s]+([^\s&]+)/i)
        if(m){ return { addr: m[1], password: m[2], name: `OBS ${m[1].split(':')[0]}` } }
        const m2 = input.match(/([\w\.-]+:\d{2,6})/)
        if(m2){ return { addr: m2[1], password: '', name: `OBS ${m2[1].split(':')[0]}` } }
        return null
      }
    }

    async function saveConfig(){
      currentConfig.common_password = $('#common-password').value
      currentConfig.import_defaults = {
        loop: $('#imp-loop').checked,
        activate: $('#imp-activate').checked,
        transition: $('#imp-transition').value,
        monitoring: $('#imp-monitoring').value,
      }
      try{ await window.go.main.App.SaveConfig(currentConfig); appendLog('info','設定を保存しました') }
      catch(e){ appendLog('error','保存に失敗: '+e) }
      renderImportDefaults()
    }

    async function testConnections(){
      try{
        const res = await window.go.main.App.TestConnections()
        const ul = $('#conn-result'); ul.innerHTML = ''
        Object.entries(res).forEach(([name, status])=>{ const li = el('div', {}, `${name}: ${status}`); li.className = status.startsWith('OK') ? 'ok' : 'ng'; ul.append(li) })
      }catch(e){ appendLog('error','接続テスト失敗: '+e) }
    }

    async function loadScenes(){
      try{
        scenes = await window.go.main.App.ListScenes()
        const box = $('#scenes'); box.innerHTML = ''
        if(!scenes || scenes.length===0){ box.append(el('div', {class:'muted'}, '共通シーンが見つかりません')); scenesLoaded = true; return }
        scenes.sort((a,b)=>a.localeCompare(b))
        scenes.forEach(s=>{ const div = el('div', {class:'scene'}); div.textContent = s; div.onclick = ()=> triggerScene(s); box.append(div) })
        scenesLoaded = true
      }catch(e){ appendLog('error','シーン一覧取得に失敗: '+e) }
    }

    async function triggerScene(name){ try{ await window.go.main.App.TriggerScene(name) }catch(e){ appendLog('error','切替開始に失敗: '+e) } }

    async function doImport(){
      const conn = $('#imp-conn').value
      const dir = $('#imp-dir').value
      const loop = $('#imp-loop').checked
      const activate = $('#imp-activate').checked
      const tr = $('#imp-transition').value
      const mon = $('#imp-monitoring').value
      try{ await window.go.main.App.ImportFromDir(conn, dir, loop, activate, tr, mon, false) }
      catch(e){ appendLog('error','インポート開始に失敗: '+e) }
    }

    async function chooseDir(){
      try{ const current = $('#imp-dir').value || ''; const res = await window.go.main.App.OpenDirectoryDialog(current, '動画ディレクトリを選択'); if(res){ $('#imp-dir').value = res } }
      catch(e){ appendLog('error','ディレクトリ選択に失敗: '+e) }
    }

    // Auto-save with debounce (500ms)
    function scheduleAutoSave(){
      clearTimeout(autosaveTimer)
      autosaveTimer = setTimeout(doAutoSave, 500)
    }
    async function doAutoSave(){
      try{ await window.go.main.App.SaveConfig(currentConfig) }catch(e){ /* silent */ }
    }

    // MIDI
    async function loadMidi(){
      try{
        await refreshMidiDevices()
        const mc = await window.go.main.App.MidiGetConfig()
        $('#midi-channel').value = mc.channel || ''
        $('#midi-debounce').value = mc.debounce || '30ms'
        $('#midi-ratelimit').value = mc.rate_limit || '50ms'
        // set mapping from config
        mappingSetFromLines(mc.mappings||[])
        if(mc.device){ const sel=$('#midi-device'); for(const o of sel.options){ if(o.value===mc.device){ sel.value=mc.device; break } } }
        // 自動生成の接続先候補
        const genSel = $('#midi-gen-conn'); genSel.innerHTML = ''
        ;(currentConfig.connections||[]).filter(c=>c.enabled!==false).forEach(c=>{ genSel.append(el('option',{value:c.name}, c.name||c.addr)) })
        if(mc.channel){ $('#midi-gen-channel').value = mc.channel }
      }catch(e){ appendLog('error','MIDI設定の読み込みに失敗: '+e) }
    }

    async function refreshMidiDevices(){
      try{
        const sel = $('#midi-device'); sel.innerHTML=''
        const names = await window.go.main.App.MidiListDevices()
        if(!names || names.length===0){ sel.append(el('option',{value:''},'(入力なし)')) }
        else { names.forEach(n=> sel.append(el('option',{value:n},n))) }
      }catch(e){ const sel = $('#midi-device'); sel.innerHTML=''; sel.append(el('option',{value:''},'(MIDI未対応ビルド)')); appendLog('error','MIDIデバイス取得に失敗: '+e) }
    }

    async function saveMidi(){
      try{
        const mc = {
          enabled: true,
          device: $('#midi-device').value || '',
          channel: $('#midi-channel').value || '',
          debounce: $('#midi-debounce').value || '30ms',
          rate_limit: $('#midi-ratelimit').value || '50ms',
          mappings: mappingToLines()
        }
        await window.go.main.App.MidiSaveConfig(mc)
        appendLog('info','MIDI設定を保存しました')
      }catch(e){ appendLog('error','MIDI設定の保存に失敗: '+e) }
    }

    async function startMidi(){ try{ await saveMidi(); await window.go.main.App.MidiStart() }catch(e){ appendLog('error','MIDI開始に失敗: '+e) } }
    async function stopMidi(){ try{ await window.go.main.App.MidiStop() }catch(e){ appendLog('error','MIDI停止に失敗: '+e) } }

    async function generateMidiMappings(){
      try{
        const conn = $('#midi-gen-conn').value
        const ch = parseInt(($('#midi-gen-channel').value||'1').trim(),10)
        const start = parseInt(($('#midi-gen-start').value||'36').trim(),10)
        if(!conn){ appendLog('error','接続先を選択してください'); return }
        if(!(ch>=1 && ch<=16)){ appendLog('error','チャネルは1..16で指定してください'); return }
        if(!(start>=0 && start<=127)){ appendLog('error','開始ノートは0..127で指定してください'); return }
        const names = await window.go.main.App.ListScenesFor(conn)
        if(!names || names.length===0){ appendLog('error','シーンが取得できませんでした'); return }
        let note = start; const lines = []
        for(const s of names){ if(note>127) break; lines.push(`${ch}:${note}=${s}`); note++ }
        mappingSetFromLines(lines)
        $('#midi-channel').value = String(ch)
        appendLog('info',`マッピングを${lines.length}件生成しました（${conn} / CH${ch} / start ${start}）`)
      }catch(e){ appendLog('error','自動生成に失敗: '+e) }
    }

    // Mapping UI (table/text toggle)
    let mappingMode = 'table'
    let mappingRows = [] // [{ch, note, scene}]
    function setMappingMode(mode){ mappingMode = (mode==='text')?'text':'table'; renderMapping() }
    function mappingSetFromLines(lines){
      mappingRows = []
      ;(lines||[]).forEach(ln=>{
        const s=(ln||'').trim(); if(!s) return
        const p=s.split('='); if(p.length<2) return
        const left=p[0].trim(); const scene=p.slice(1).join('=').trim(); if(!scene) return
        const ln2=left.split(':'); if(ln2.length!=2) return
        const ch=parseInt(ln2[0],10); const note=parseInt(ln2[1],10)
        if(!(ch>=1&&ch<=16)) return; if(!(note>=0&&note<=127)) return
        mappingRows.push({ch, note, scene})
      })
      renderMapping()
    }
    function mappingToLines(){
      if(mappingMode==='text'){
        const ta=$('#midi-mappings'); const txt=(ta&&ta.value)?ta.value:''
        return txt.split('\n').map(s=>s.trim()).filter(Boolean)
      }
      const out=[]; mappingRows.forEach(r=>{
        const ch=parseInt(r.ch,10), note=parseInt(r.note,10), scene=(r.scene||'').trim()
        if(ch>=1&&ch<=16&&note>=0&&note<=127&&scene){ out.push(`${ch}:${note}=${scene}`) }
      }); return out
    }
    function renderMapping(){
      const box=$('#mapping-container'); if(!box) return; box.innerHTML=''
      if(mappingMode==='text'){
        const ta=el('textarea',{id:'midi-mappings',style:'width:100%; height:140px; background:#0b1220; color:#e2e8f0; border:1px solid #334155; border-radius:6px; padding:6px 8px;'},'')
        ta.value = mappingRows.map(r=>`${r.ch}:${r.note}=${r.scene}`).join('\n')
        box.append(ta); return
      }
      const tbl=el('table',{class:'map'}), thead=el('thead'), hr=el('tr');
      ;['CH','Note','Scene',''].forEach(h=>hr.append(el('th',{},h))); thead.append(hr); tbl.append(thead)
      const tbody=el('tbody')
      mappingRows.forEach((row,idx)=>{
        const tr=el('tr')
        const tdCh=el('td'); const inCh=el('input',{type:'number',min:'1',max:'16',value:String(row.ch||1)}); inCh.onchange=()=>{row.ch=parseInt(inCh.value||'1',10)||1}; tdCh.append(inCh)
        const tdNote=el('td'); const inNote=el('input',{type:'number',min:'0',max:'127',value:String(row.note||0)}); inNote.onchange=()=>{row.note=parseInt(inNote.value||'0',10)||0}; tdNote.append(inNote)
        const tdScene=el('td'); const inScene=el('input',{type:'text',value:row.scene||''}); inScene.oninput=()=>{row.scene=inScene.value}; tdScene.append(inScene)
        const tdAct=el('td'); const del=el('button',{},'削除'); del.onclick=()=>{mappingRows.splice(idx,1); renderMapping()}; tdAct.append(del)
        tr.append(tdCh,tdNote,tdScene,tdAct); tbody.append(tr)
      }); tbl.append(tbody)
      const add=el('div',{class:'row'},''); const btn=el('button',{},'行を追加'); btn.onclick=()=>{mappingRows.push({ch:1,note:36,scene:''}); renderMapping()}; add.append(btn)
      box.append(tbl, add)
    }

    function appendLog(level, msg){ const box = $('#log'); const line = `[${new Date().toLocaleTimeString()}] ${level.toUpperCase()}: ${msg}`; const div = el('div', {class: level==='error'?'ng':'ok'}, line); box.append(div); box.scrollTop = box.scrollHeight }

    document.addEventListener('DOMContentLoaded', ()=>{
      if(window.runtime && window.runtime.EventsOn){ window.runtime.EventsOn('log', (p)=>{ appendLog(p.level||'info', p.msg || '') }) }
      loadConfig(); loadMidi()
      setView('connections')
    })

    async function openMidiTest(){
      try{ await window.go.main.App.OpenExternalURL('https://studiocode.dev/webmidi-tester/') }
      catch(e){ appendLog('error','ブラウザ起動に失敗: '+e) }
    }

    // View switching (Settings-like)
    function setView(name){
      const views = ['scenes','connections','import','midi','logs']
      views.forEach(v=>{
        const elv = document.getElementById('view-'+v)
        if(elv){ elv.classList.toggle('hidden', v!==name) }
      })
      const buttons = document.querySelectorAll('.nav button')
      buttons.forEach(b=>{ b.classList.toggle('active', (b.dataset && b.dataset.view) === name) })
      // When opening the Scenes view, auto-load only if not yet loaded once
      if(name === 'scenes'){
        try{
          if(!scenesLoaded){
            loadScenes()
          }
        }catch(_){ /* noop */ }
      }
    }
    function labelOf(name){
      switch(name){
        case 'scenes': return 'シーン 切り替え'
        case 'connections': return '接続'
        case 'import': return 'シーン 一括作成'
        case 'midi': return 'シーン 自動切替（MIDI）'
        case 'logs': return 'ログ'
        default: return ''
      }
    }
  </script>
</head>
<body>
  <header>
    <h1>obsctl GUI</h1>
  </header>
  <main>
    <aside>
      <div class="nav">
        <button class="active" data-view="connections" onclick="setView('connections')">OBSに接続（WebSocket）</button>
        <button data-view="scenes" onclick="setView('scenes')">シーン 手動切替</button>
        <button data-view="midi" onclick="setView('midi')">シーン 自動切替（MIDI）</button>
        <button data-view="import" onclick="setView('import')">シーン 一括作成</button>
        <button data-view="logs" onclick="setView('logs')">ログ</button>
      </div>
    </aside>
    <div id="content">
      <div id="view-scenes" class="card">
        <div class="row">
          <button onclick="loadScenes()">共通シーンを読み込み</button>
          <span class="muted">（全接続に存在するシーンのみ表示）</span>
        </div>
        <div id="scenes" class="scenes"></div>
      </div>

      <div id="view-connections" class="card hidden" style="margin-top:16px;">
        <h3>OBSに接続（WebSocket）</h3>
        <div id="conn-list" class="list"></div>
        <div class="row">
          <button onclick="addConnection()">接続を追加</button>
          <button class="icon-btn" onclick="addByQR()" title="QRで追加" aria-label="QRで追加">
            <img src="img/icon_qr.svg" width="18" height="18" alt="" aria-hidden="true" />
          </button>
        </div>
        <div class="row">サーバーパスワード: <input type="password" id="common-password" placeholder="password" /></div>
        <div class="row">
          <button onclick="testConnections()">接続テスト</button>
        </div>
        <div id="conn-result" class="list"></div>
      </div>

      <div id="view-import" class="card hidden" style="margin-top:16px;">
        <h3>シーン一括作成</h3>
        <div class="row"><small class="muted">選択したフォルダの動画・画像をシーンとしてまとめて登録します</small></div>
        <div class="grid2">
          <div>登録先OBS: <select id="imp-conn"></select></div>
          <div>ディレクトリ: <input id="imp-dir" class="grow" placeholder="/path/to/videos" /> <button onclick="chooseDir()">選択…</button></div>
          <div>トランジション: 
            <select id="imp-transition"><option value="fade">fade</option><option value="cut">cut</option></select>
          </div>
          <div>モニタリング: 
            <select id="imp-monitoring">
              <option value="off">off</option>
              <option value="monitor-only">monitor-only</option>
              <option value="monitor-and-output">monitor-and-output</option>
            </select>
          </div>
          <div>ループ:
            <label class="switch"><input type="checkbox" id="imp-loop" aria-label="ループ" /><span class="slider"></span></label>
          </div>
          <div>作成後にアクティブ化:
            <label class="switch"><input type="checkbox" id="imp-activate" aria-label="作成後にアクティブ化" /><span class="slider"></span></label>
          </div>
        </div>
        <div class="row"><button onclick="doImport()">インポート実行</button></div>
      </div>

      <div id="view-midi" class="card hidden" style="margin-top:16px;">
        <h3>MIDI</h3>
        <div class="grid2">
          <div>デバイス: <select id="midi-device"></select> <button onclick="refreshMidiDevices()">更新</button></div>
          <div>チャネル: <input id="midi-channel" placeholder="例: 1,2 (未指定は全て)" /></div>
          <div>デバウンス: <input id="midi-debounce" placeholder="30ms" /></div>
          <div>レート制限: <input id="midi-ratelimit" placeholder="50ms" /></div>
        </div>
        <div class="row">
          <button onclick="openMidiTest()">WebMIDIテストページを開く</button>
        </div>
        <div class="row">
          <strong>自動生成:</strong>
          <span>接続先</span>
          <select id="midi-gen-conn"></select>
          <span>チャネル</span>
          <input id="midi-gen-channel" value="1" style="width:60px" />
          <span>開始ノート</span>
          <input id="midi-gen-start" value="36" style="width:60px" />
          <button onclick="generateMidiMappings()">生成して置換</button>
        </div>
        <div class="row">
          <strong>表示:</strong>
          <button onclick="setMappingMode('table')">表</button>
          <button onclick="setMappingMode('text')">テキスト</button>
          <span class="muted">（保存時はどちらの表示でもOK）</span>
        </div>
        <div id="mapping-container"></div>
        <div class="row">
          <button onclick="saveMidi()">MIDI設定を保存</button>
          <button onclick="startMidi()">開始</button>
          <button onclick="stopMidi()">停止</button>
        </div>
      </div>

      <div id="view-logs" class="card hidden" style="margin-top:16px;">
        <h3>ログ</h3>
        <div id="log" class="log"></div>
      </div>
    </div>
  </main>
</body>
</html>
